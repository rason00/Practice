# 4.2 执行环境及作用域

**执行环境（execution context，也称为“环境”）是 JavaScript 中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它**。

# 内容涵盖

1. 延长作用域链
2. 没有块级作用域
    1. 声明变量
    2. 查询标识符

**全局执行环境是最外围的一个执行环境**。在 Web 浏览器中，全局执行环境被认为是 window 对象（第 7 章将详细讨论），因此所有全局变量和函数都是作为 window 对象的属性和方法创建的。**某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）**。

**每个函数都有自己的执行环境**。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。

**当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）**。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。**作用域链的前端，始终都是当前执行的代码所在环境的变量对象**。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。

作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延
续到全局执行环境；**全局执行环境的变量对象始终都是作用域链中的最后一个对象**。标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。

请看下面的示例代码：

```
var color = "blue";
function changeColor(){
 if (color === "blue"){
 color = "red";
 } else {
 color = "blue";
 }
}
changeColor();
alert("Color is now " + color);
```

> 可以在函数内部访问变量 color，就是因为可以在这个作用域链中找到它。

此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使用，如下面这个例子所示：

```
var color = "blue";
function changeColor(){
 var anotherColor = "red";
 function swapColors(){
 var tempColor = anotherColor;
 anotherColor = color;
 color = tempColor;
 // 这里可以访问 color、anotherColor 和 tempColor
 }
 // 这里可以访问 color 和 anotherColor，但不能访问 tempColor
 swapColors();
}
// 这里只能访问 color
changeColor();
```

> 以上代码共涉及 3 个执行环境：全局环境、changeColor()的局部环境和 swapColors()的局部环境。

**内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数**。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。

> 函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。

# 4.2.1 延长作用域链

虽然执行环境的类型总共只有两种——全局和局部（函数），但还是有其他办法来延长作用域链。**有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除**。在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长：

1. try-catch 语句的 catch 块；
2. with 语句。

这两个语句都会在作用域链的前端添加一个变量对象。

对 with 语句来说，会将指定的对象添加到作用域链中。

对 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。

下面看一个例子。

```
function buildUrl() {
 var qs = "?debug=true";
 with(location){        // 在作用域链的前端添加一个变量对象
 var url = href + qs;
 }
 return url;
}
```

> with 语句接收的是 location 对象，因此其变量对象中就包含了 location 对象的所有属性和方法，而这个变量对象被添加到了作用域链的前端。

在 IE8 及之前版本的 JavaScript 实现中，存在一个与标准不一致的地方，即在catch 语句中捕获的错误对象会被添加到执行环境的变量对象，而不是 catch 语句的变量对象中。换句话说，即使是在 catch 块的外部也可以访问到错误对象。IE9 修复了这个问题。

# 4.2.2 没有会计作用域

JavaScript 没有块级作用域经常会导致理解上的困惑。例如，下面的代码在 JavaScript 中并不会得到想象中的结果：

```
if (true) {
 var color = "blue";
}
alert(color); //"blue"
```

> 这里是在一个 if 语句中定义了变量 color。如果是在 C、C++或 Java 中，color 会在 if 语句执行完毕后被销毁。但在 JavaScript 中，if 语句中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）中。

在使用 for 语句时尤其要牢记这一差异，例如：

```
for (var i=0; i < 10; i++){
 doSomething(i);
}
alert(i); //10
```

> 对于有块级作用域的语言来说，for 语句初始化变量的表达式所定义的变量，只会存在于循环的环境之中。而对于 JavaScript 来说，由 for 语句创建的变量 i 即使在 for 循环执行结束后，也依旧会存在于循环外部的执行环境中。

## 1. 声明变量

**使用 var 声明的变量会自动被添加到最接近的环境中**。

1. 在函数内部，最接近的环境就是函数的局部环境；

2. 在 with 语句中，最接近的环境是函数环境。

如果初始化变量时没有使用 var 声明，该变量会自动被添加到全局环境。如下所示：

```
function add(num1, num2) {
 var sum = num1 + num2;   // var 声明的是局部变量
 return sum;
}
var result = add(10, 20); //30
alert(sum); //由于 sum 不是有效的变量，因此会导致错误
```

> 变量 sum 在函数外部是访问不到的。如果省略这个例子中的 var 关键字，那么当 add()执行完毕后，sum 也将可以访问到：

```
function add(num1, num2) {
 sum = num1 + num2;   // 没有了 var ，即声明了个全局变量
 return sum;
}
var result = add(10, 20); //30
alert(sum); //30
```

> 变量 sum 在被初始化赋值时没有使用 var 关键字。于是，当调用完 add()之后，添加到全局环境中的变量 sum 将继续存在.

不声明而直接初始化变量是一个常见的错误做法，因为这样可能会导致意外。我们建议在初始化变量之前，一定要先声明，这样就可以避免类似问题。在严格模式下，初始化未经声明的变量会导致错误。

## 2. 查询标识符

当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。

**搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明**。

通过下面这个示例，可以理解查询标识符的过程：

```
var color = "blue";
function getColor(){
 return color;     // 这里的 color 会先在此作用域寻找，没有再向上级寻找。
}
alert(getColor()); // "blue"
```

> 调用本例中的函数 getColor() 时会引用变量 color。为了确定变量 color 的值。首先，搜索 getColor() 的变量对象，查找其中是否包含一个名为 color 的标识符。在没有找到的情况下，搜索继续到下一个变量对象（全局环境的变量对象），然后在那里找到了名为color 的标识符。因为搜索到了定义这个变量的变量对象，搜索过程宣告结束。

如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符，如下面的例子所示：

```
var color = "blue";
function getColor(){
 var color = "red";
 return color;     // color会先在本作用域寻找，找到了，因此不会用到上一级的
}
alert(getColor()); //"red"
```

> 搜索过程首先从局部环境中开始，而且在这里发现了一个名为 color 的变量，其值为"red"。因为变量已经找到了，所以搜索即行停止，return 语句就使用这个局部变量，并为函数会返回"red"。也就是说，任何位于局部变量 color 的声明之后的代码，如果不使用 window.color 都无法访问全局 color变量。

变量查询也不是没有代价的。很明显，访问局部变量要比访问全局变量更快，因为不用向上搜索作用域链。JavaScript 引擎在优化标识符查询方面做得不错，因此这个差别在将来恐怕就可以忽略不计了。
