# 3.5 操作符

**ECMA-262 描述了一组用于操作数据的操作符，包括算术操作符、位操作符（不讲此操作符）、关系操作符和相等操作符。**

# 内容涵盖

1. 一元操作符
2. 位操作符
3. 布尔操作符
    1. 逻辑非
    2. 逻辑与
    3. 逻辑或
4. 乘性操作符
    1. 乘法
    2. 除法
    3. 求模
5. 加性操作符
    1. 加法
    2. 减法
6. 关系操作符
7. 相等操作符
    1. 相等和不相等
    2. 全等和不全等
8. 条件操作符
9. 赋值操作符
10. 逗号操作符

# 3.5.1 一元操作符

**只能操作一个值的操作符叫做一元操作符。是 ECMAScript 中最简单的操作符。**

## 1. 递增和递减操作符

递增和递减操作符直接借鉴自 C，而且各有两个版本：**前置型和后置型。顾名思义，前置型应该位于要操作的变量前，而后置型则应该位于要操作的变量之后。**

**前置型：**

```
var age = 29;
var anotherAge = --age + 2;

alert(age);                 // 输出 28
alert(anotherAge);          // 输出 30 

var num1 = 1;
var num2 = 20;
var num3 = ++num1 + num2;   // 等于 22
var num4 = num1 + num2;     // 等于 22 
```
> **执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。**

**后置型：**

```
var num1 = 2;
var num2 = 20;
var num3 = num1-- + num2;   // 等于 22
var num4 = num1 + num2;     // 等于 21 
```
> **后置型递增和递减操作是在包含它们的语句被求值之后才执行的。**

所有这 4 个操作符对任何值都适用，也就是它们不仅适用于整数，还可以用于字符串、布尔值、浮点数值和对象。在应用于不同的值时，递增和递减操作符遵循下列规则。

1. 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减 1 的操作。字符串变量变成数值变量。
2. 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为 NaN（第 4 章将详细讨论）。字符串变量变成数值变量。
3. 在应用于布尔值 false 时，先将其转换为 0 再执行加减 1 的操作。布尔值变量变成数值变量。
4. 在应用于布尔值 true 时，先将其转换为 1 再执行加减 1 的操作。布尔值变量变成数值变量。
5. 在应用于浮点数值时，执行加减 1 的操作。
6. 在应用于对象时，先调用对象的 valueOf()方法（第 5 章将详细讨论）以取得一个可供操作的值。然后对该值应用前述规则。如果结果是 NaN，则在调用 toString()方法后再应用前述规则。对象变量变成数值变量。

以下示例展示了上面的一些规则：

```
var s1 = "2";
var s2 = "z";
var b = false;
var f = 1.1;
var o = {
 valueOf: function() {
 return -1;
 }
};
s1++; // 值变成数值 3
s2++; // 值变成 NaN
b++;  // 值变成数值 1
f--;  // 值变成 0.10000000000000009（由于浮点舍入错误所致）
o--;  // 值变成数值-2 
```
## 2. 一元加和减操作符

**一元加操作符以一个加号（+）表示，放在数值前面，对数值不会产生任何影响。而一元减就相当于一个负号。**

```
//一元加
var s1 = "01";
var s2 = "1.1";
var s3 = "z";
var b = false;
var f = 1.1;
var o = {
 valueOf: function() {
 return -1;
 }
};
s1 = +s1; // 值变成数值 1
s2 = +s2; // 值变成数值 1.1
s3 = +s3; // 值变成 NaN
b = +b;   // 值变成数值 0
f = +f;   // 值未变，仍然是 1.1
o = +o;   // 值变成数值-1

//一元减
var s1 = "01";
var s2 = "1.1";
var s3 = "z";
var b = false;
var f = 1.1;
var o = {
 valueOf: function() {
 return -1;
 }
};
s1 = -s1; // 值变成了数值-1
s2 = -s2; // 值变成了数值-1.1
s3 = -s3; // 值变成了 NaN
b = -b;   // 值变成了数值 0
f = -f;   // 变成了-1.1
o = -o;   // 值变成了数值 1 
```

# 3.5.2 位操作符
《略》

# 3.5.3 布尔操作符

**布尔操作符一共有 3 个：非（NOT）、与（AND）和或（OR）。**

## 1. 逻辑非

**逻辑非操作符由一个叹号（！）表示。无论这个值是什么数据类型，这个操作符都会返回一个布尔值**。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反。也就是说，逻辑非操作符遵循下列规则：

1. 如果操作数是一个对象，返回 false；
2. 如果操作数是一个空字符串，返回 true；
3. 如果操作数是一个非空字符串，返回 false；
4. 如果操作数是数值 0，返回 true；
5. 如果操作数是任意非 0 数值（包括 Infinity），返回false；
6. 如果操作数是 null，返回 true；
7. 如果操作数是 NaN，返回 true；
8. 如果操作数是 undefined，返回 true。

下面几个例子展示了应用上述规则的结果：

```
alert(!false);  // true
alert(!"blue"); // false
alert(!0);      // true
alert(!NaN);    // true
alert(!"");     // true
alert(!12345);  // false 
```

## 2. 逻辑与

**逻辑与操作符由两个和号（&&）表示**，有两个操作数，如下面的例子所示：

```
var result = true && false; 
```

逻辑与的真值表如下：

| 第一个操作数  | 第二个操作数  | 结 果  |
| -----------  |  ----------  | ----  |
| true         |  true        | true  |
| true         |  false       | false |
| false        |  true        | false |
| false        |  false       | false |

> **规则就是一假必假**

逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；此时，它遵循下列规则：

1. 如果第一个操作数是对象，则返回第二个操作数；
2. 如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象；
3. 如果两个操作数都是对象，则返回第二个操作数；
4. 如果有一个操作数是 null，则返回 null；
5. 如果有一个操作数是 NaN，则返回 NaN；
6. 如果有一个操作数是 undefined，则返回 undefined。

逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。即：如果第一个操作数是 false，则无论第二个操作数是什么值，结果都不再可能是 true 了。来看下面的例子：

```
var found = true;   //注意这里的true
var result = (found && someUndefinedVariable);
//因为 found 是 true ，它会继续执行后面条件，但是 someUndefinedVariable 未声明，所以会发生错误。
alert(result); // 这一行不会执行

var found = false;  //注意这里的false
var result = (found && someUndefinedVariable);
//因为 found 是 false，已经决定了结果，所以后面的条件语不会执行，哪怕后面条件于是错误的（没有被声明）
alert(result); // 会执行（"false"）
```

## 3. 逻辑或

**逻辑或操作符由两个竖线符号（||）表示**，有两个操作数，如下面的例子所示：
```
var result = true || false;
```

逻辑或的真值表如下：

| 第一个操作数  | 第二个操作数  | 结 果 |
| -----------  |  ----------  | ----  |
| True          | true        | true  |
| True          | false       | true  |
| false         | true        | true  |
| false         | false       | false |

> **一真必真**

与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值；此时，它遵循下列规则：

1. 如果第一个操作数是对象，则返回第一个操作数；
2. 如果第一个操作数的求值结果为 false，则返回第二个操作数；
3. 如果两个操作数都是对象，则返回第一个操作数；
4. 如果两个操作数都是 null，则返回 null；
5. 如果两个操作数都是 NaN，则返回 NaN；
6. 如果两个操作数都是 undefined，则返回 undefined

**逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果为 true，就不会对第二个操作数求值了**。下面看一个例子：

```
var found = true; // 注意这里的 true
var result = (found || someUndefinedVariable);
// 因为 found 是 true ，已经决定了结果，所以后面的条件语不会执行，哪怕是错误的（未声明）。
alert(result); // 会执行（"true"）

var found = false;  // 注意这里的 false
var result = (found || someUndefinedVariable); 
// 因为 found 是 false ，需要继续执行后面条件语来判断，而后面是个未声明的值，所以会发生错误。
alert(result); // 这一行不会执行
```

我们可以利用逻辑或的这一行为来避免为变量赋 null 或 undefined 值。例如：

```
var myObject = preferredObject || backupObject;
```

在这个例子中，变量 myObject 将被赋予等号后面两个值中的一个。变量 preferredObject 中包含优先赋给变量myObject 的值，变量 backupObject 负责在preferredObject 中不包含有效值的情况下提供后备值。如果 preferredObject 的值不是 null，那么它的值将被赋给 myObject；如果是 null，则将 backupObject 的值赋给 myObject。

# 3.5.4 乘性操作符
**ECMAScript 定义了 3 个乘性操作符：乘法、除法和求模**。在操作数为非数值的情况下会执行自动的类型转换。如果参与乘性计算的某个操作数不是数值，后台会先使用 Number() 转型函数将其转换为数值。也就是说，空字符串将被当作 0，布尔值 true 将被当作 1。

## 1. 乘法

**乘法操作符由一个星号（*）表示，用于计算两个数值的乘积**。如下面的例子所示：

```
var result = 34 * 56;
```

在处理特殊值的情况下，乘法操作符遵循下列特殊的规则：

1. 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了 ECMAScript 数值的表示范围，则返回 Infinity 或-Infinity；
2. 如果有一个操作数是 NaN，则结果是 NaN；
3. 如果是 Infinity 与 0 相乘，则结果是 NaN；
4. 如果是 Infinity 与非 0 数值相乘，则结果是Infinity 或-Infinity，取决于有符号操作数的符号；
5. 如果是 Infinity 与 Infinity 相乘，则结果是Infinity；
6. 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。

## 2. 除法

**除法操作符由一个斜线符号（/）表示，执行第二个操作数除第一个操作数的计算**，如下面的例子所示：

```
var result = 66 / 11;
```

与乘法操作符类似，除法操作符对特殊的值也有特殊的处理规则。这些规则如下：

1. 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了 ECMAScript 数值的表示范围，则返回 Infinity 或-Infinity；
2. 如果有一个操作数是 NaN，则结果是 NaN；
3. 如果是 Infinity 被 Infinity 除，则结果是 NaN；
4. 如果是零被零除，则结果是 NaN；
5. 如果是非零的有限数被零除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；
6. 如果是 Infinity 被任何非零数值除，则结果是Infinity 或-Infinity，取决于有符号操作数的符号；
7. 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。

## 3. 求模

**求模（余数）操作符由一个百分号（%）表示**，用法如下：

```
var result = 26 % 5; // 等于 1
```

与另外两个乘性操作符类似，求模操作符会遵循下列特殊规
则来处理特殊的值：

1. 如果操作数都是数值，执行常规的除法计算，返回除得的余数；
2. 如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN；
3. 如果被除数是有限大的数值而除数是零，则结果是 NaN；
4. 如果是 Infinity 被 Infinity 除，则结果是 NaN；
5. 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；
6. 如果被除数是零，则结果是零；
7. 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。

# 3.5.5 加性操作符

**加法和减法这两个操作符都有一系列的特殊行为。与乘性操作符类似，加性操作符也会在后台转换不同的数据类型**。

## 1. 加法

加法操作符（+）的用法如下所示：

```
var result = 1 + 2;
```

如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果：

1. 如果有一个操作数是 NaN，则结果是 NaN；
2. 如果是 Infinity 加 Infinity，则结果是 Infinity；
3. 如果是-Infinity 加-Infinity，则结果 -Infinity；
4. 如果是 Infinity 加-Infinity，则结果是 NaN；
5. 如果是 +0 加 +0，则结果是 +0；
6. 如果是 -0 加 -0，则结果是 -0；
7. 如果是 +0 加 -0，则结果是 +0。

不过，如果有一个操作数是字符串，那么就要应用如下规则：

1. 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；
2. 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。

如果有一个操作数是对象、数值或布尔值，则调用它们的 toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于 undefined 和 null，则分别调用String()函数并取得字符串"undefined"和"null"。

下面来举几个例子：

```
var result1 = 5 + 5; // 两个数值相加
alert(result1); // 10 

var result2 = 5 + "5"; // 一个数值和一个字符串相加
alert(result2); // "55" 字符串
```

忽视加法操作中的数据类型是 ECMAScript 编程中最常见的一个错误。再来看一个例子：

```
// 错误
var num1 = 5;
var num2 = 10;
var message = "The sum of 5 and 10 is " + num1 + num2;
alert(message); // "The sum of 5 and 10 is 510" 

//正确
var num1 = 5;
var num2 = 10;
var message = "The sum of 5 and 10 is " + (num1 + num2);
alert(message); //"The sum of 5 and 10 is 15" 
```

## 2. 减法

**减法操作符（-）是另一个极为常用的操作符**，其用法如下所示：

```
var result = 2 - 1;
```

与加法操作符类似，ECMAScript 中的减法操作符在处理各种数据类型转换时，同样需要遵循一些特殊规则，如下所示：

1. 如果两个操作符都是数值，则执行常规的算术减法操作并返回结果；
2. 如果有一个操作数是 NaN，则结果是 NaN；
3. 如果是 Infinity 减 Infinity，则结果是 NaN；
4. 如果是 -Infinity 减 -Infinity，则结果是 NaN；
5. 如果是 Infinity 减 -Infinity，则结果是 Infinity；
6. 如果是 -Infinity 减 Infinity，则结果 -Infinity；
7. 如果是 +0 减 +0，则结果是 +0；
8. 如果是 +0 减 -0，则结果是 -0；
9. 如果是 -0 减 -0，则结果是 +0；
10. 如果有一个操作数是字符串、布尔值、null 或  undefined，则先在后台调用 Number() 函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果就是 NaN；
11. 如果有一个操作数是对象，则调用对象的 valueOf() 方法以取得表示该对象的数值。如果得到的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf() 方法，则调用其 toString() 方法并将得到的字符串转换为数值。

下面几个例子展示了上面的规则：

```
var result1 = 5 - true; // 4，因为 true 被转换成了 1
var result2 = NaN - 1;  // NaN
var result3 = 5 - 3;    // 2
var result4 = 5 - "";   // 5，因为"" 被转换成了 0
var result5 = 5 - "2";  // 3，因为"2"被转换成了 2
var result6 = 5 - null; // 5，因为 null 被转换成了 0 
```

# 3.5.6 关系操作符

**小于（<）、大于（>）、小于等于（<=）和大于等于（>=）这几个关系操作符用于对两个值进行比较**，比较的规则与我们在数学课上所学的一样。这几个操作符都返回一个布尔值，如下面的例子所示：

```
var result1 = 5 > 3; //true
var result2 = 5 < 3; //false
```

与 ECMAScript 中的其他操作符一样，当关系操作符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作。以下就是相应的规则。

2. 如果两个操作数都是数值，则执行数值比较。
3. 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。
4. 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。
5. 如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf() 方法，则调用 toString() 方法，并用得到的结果根据前面的规则执行比较。
6. 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。

在使用关系操作符比较两个字符串时，会执行一种奇怪的操作。**在比较字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值**。经过这么一番比较之后，再返回一个布尔值。由于大写字母的字符编码全部小于小写字母的字符编码，因此我们就会看到如下所示的奇怪现象：

```
var result = "Brick" < "alphabet"; //true
```

> 因是字母 B 的字符编码为 66，而字母 a 的字符编码是 97。

如果要真正按字母表顺序比较字符串，就必须把两个操作数转换为相同的大小写形式（全部大写或全部小写），然后再执行比较，如下所示：

```
var result = "Brick".toLowerCase() < "alphabet".toLowerCase(); //false
```

> 通过将两个操作数都转换为小写形式，就可以得出"alphabet"按字母表顺序排在"Brick"之前的正确判断了。

另一种奇怪的现象发生在比较两个数字字符串的情况下，比如下面这个例子：

```
var result = "23" < "3"; //true
```

> （"2"的字符编码是 50，而"3"的字符编码是 51）。

不过，如果像下面例子中一样，将一个操作数改为数值，比较的结果就正常了：

```
var result = "23" < 3; //false
```

> 此时，字符串"23"会被转换成数值 23，然后再与 3 进行比较，因此就会得到合理的结果。

**在比较数值和字符串时，字符串都会被转换成数值，然后再以数值方式与另一个数值比较**。

如果那个字符串不能被转换成一个合理的数值呢？比如：

```
var result = "a" < 3; // false，因为"a"被转换成了 NaN
```

> 由于字母"a"不能转换成合理的数值，因此就被转换成了 NaN。根据规则，任何操作数与 NaN 进行关系比较，结果都是 false。

于是，就出现了下面这个有意思的现象：

```
var result1 = NaN < 3; //false
var result2 = NaN >= 3; //false
```

> 按照常理，如果一个值不小于另一个值，则一定是大于或等于那个值。然而，在与 NaN 进行比较时，这两个比较操作的结果都返回了 false。

# 3.5.7 相等操作符

**ECMAScript 提供两组操作符：相等和不相等——先转换再比较，全等和不全等——仅比较而不转换**。

## 1. 相等和不相等

相等操作符由两个等于号（==）表示，如果两个操作数相等，则返回 true。

不相等操作符由叹号后跟等于号（!=）表示，如果两个操作数不相等，则返回 true。

这两个操作符都会先转换操作数（通常称为强制转型），然后再比较它们的相等性。

在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：

1. 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为 0，而 true 转换为 1；
2. 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；
3. 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类型值按照前面的规则进行比较；

这两个操作符在进行比较时则要遵循下列规则。

1. null 和 undefined 是相等的。
2. 要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。
3. 如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。重要提示：即使两个操作数都是 NaN，相等操作符也返回 false；因为按照规则，NaN 不等于 NaN。
4. 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true；否则，返回 false。

下表列出了一些特殊情况及比较结果：

| 表 达 式           | 值 |
| ----------------- | --- |
| null == undefined | true |
| "NaN" == NaN      | false | 
| 5 == NaN          | false |
| NaN == NaN         |  false |
| NaN != NaN         |  true |
| false == 0         |  true |
| true == 1         | true  |
| true == 2         | false |
| undefined == 0    |  false  |
| null == 0         | false |
| "5"==5            |  true |

## 2. 全等和不全等

**全等操作符由 3 个等于号（===）表示，它只在两个操作数未经转换就相等的情况下返回 true**，如下面的例子所示：

```
var result1 = ("55" == 55); //true，因为转换后相等
var result2 = ("55" === 55); //false，因为不同的数据类型不相等
```

> 全等（===）不会转换数据

**不全等操作符由一个叹号后跟两个等于号（!==）表示，它在两个操作数未经转换就不相等的情况下返回 true**。例如：

```
var result1 = ("55" != 55); //false，因为转换后相等
var result2 = ("55" !== 55); //true，因为不同的数据类型不相等
```

> 不全等（!==）不会转换数据

**记住：null == undefined 会返回 true，因为它们是类似的值；但 null === undefined 会返回 false，因为它们是不同类型的值**。

> **由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，推荐使用全等和不全等操作符。**

# 3.5.8 条件操作符

条件操作符应该算是 ECMAScript 中最灵活的一种操作符了，而且它遵循与 Java 中的条件操作符相同的语法形式，如下面的例子所示：

```
variable = boolean_expression ? true_value : false_value;
```

> 这行代码的含义就是基于对 boolean_expression 求值的结果，决定给变量 variable 赋什么值。如果求值结果为 true，则给变量 variable 赋 true_value 值；如果求值结果为 false，则给变量 variable 赋 false_value 值。

再看一个例子：

```
var max = (num1 > num2) ? num1 : num2;
```

> 这个表达式的意思是：如果 num1 大于 num2（关系表达式返回 true），则将 num1 的值赋给 max；如果 num1 小于或等于 num2（关系表达式返回 false），则将 num2 的值赋给 max。

# 3.5.9 赋值操作符

**简单的赋值操作符由等于号（=）表示，其作用就是把右侧的值赋给左侧的变量**，如下面的例子所示：

```
var num = 10;
```

如果在等于号（=）前面再添加乘性操作符、加性操作符或位操作符，就可以完成复合赋值操作。这种复合赋值操作相当于是对下面常规表达式的简写形式：

```
var num = 10;
num = num + 10;
//其中的第二行代码可以用一个复合赋值来代替：
var num = 10;
num += 10;
```

每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示：

1. 乘/赋值（*=）；
2. 除/赋值（/=）；
3. 模/赋值（%=）；
4. 加/赋值（+=）；
5. 减/赋值（-=）；
6. 左移/赋值（<<=）；
7. 有符号右移/赋值（>>=）；
8. 无符号右移/赋值（>>>=）。

> 设计这些操作符的主要目的就是简化赋值操作。使用它们不会带来任何性能的提升。

# 3.5.10 逗号操作符

**使用逗号操作符可以在一条语句中执行多个操作**，如下面的例子所示：

```
var num1=1, num2=2, num3=3;
```

> 逗号操作符多用于声明多个变量；

除此之外，**逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项**，如下面的例子所示：

```
var num = (5, 1, 4, 8, 0); // num 的值为 0
```

> 由于 0 是表达式中的最后一项，因此 num 的值就是 0。
